บรรทัด  41 Yt = data[None,initLen+1:trainLen+1] 

ซึ่งเป็นการเก็บค่า data เข้าไปที่ yt ซึ่งเก็บเป็นจำนวณ 1 แถวโดย มาจาก แถวที่  0 โดยถุกกำหนดจากNone และหลักที่ถูกกำหนดจุดเริ่ม ด้วย  initLen+1 และสิ้นสุด trainLen+1
จากการไปศึกษาเพิ่มเติมมา : คือตัวกำหนดจุดเริ่มต้นหรือจุดสิ้นสุด เขียนโค้ให้เข้าใจเช่น data[start : end ]
ผลของการลองปริ้น YT มาจะเป็น 
[[-0.09351762 -0.14571328 -0.19540772 ... -0.30151187 -0.33570312
  -0.36746866]] จะเป็น row จำนวน 1 แถว โดยหลักเริ่มจาก initLen+1 ไปจนถึง trainLen+1
  
  
  

วิเคราะห์โค้ดตั้งแต่ 44-49
x = np.zeros((resSize,1))
for t in range(trainLen):
    u = data[t]
    x = (1-a)*x + a*np.tanh( np.dot( Win, np.vstack((1,u)) ) + np.dot( W, x ) )
    if t >= initLen:
        X[:,t-initLen] = np.vstack((1,u,x))[:,0]
		
		
บรรทัดแรกจะเป็นการเก็บค่า x โดยให้ x เป็น เมตริกสองมิติที่มี 0 ทุกตัวโดย row เท่ากับ resSize คือ 1000 และ column เท่ากับ 1
โดยลองปริ้นออกมาจะได้ 
[[0.]
 [0.]
 [0.]
 [0.]
 .
 .
 .
 [0.]]
 
ส่วนต่อมา for t in range(trainLen): เป็นการวนลูปเท่า trainLen = 2000 ตัวโดยเริ่มจาก t ที่ 0 ถึง 1999 


u=data[t] จะเป็นการเก็บค่า ของดาต้าไปเรื่อยๆโดยเริ่มจาก data[0]


x = (1-a)*x + a*np.tanh( np.dot( Win, np.vstack((1,u)) ) + np.dot( W, x ) )

จะเป็นการเก็บค่า โดยที่  a = 0.3 
x  = 0.7* [[0.] (x ก่อนหน้านี้ ที่ถูกกำหนดให้ x = np.zeros((resSize,1)))
 [0.]
 [0.]
 [0.]
 .
 .
 .
 [0.]] 
 และ 0.7*np.tanh( np.dot( Win, np.vstack((1,u)) ) + np.dot( W, x ) )
 โดย np.tanh เป็นการเรียกใช้ฟังชั้นก์ tanh โดยข้างในจะเป็นจะเป็นการ  dot กันของ Win ซึ่งก่อนหน้านั้น 
 Win = (np.random.rand(resSize,1+inSize) - 0.5) * 1 
 ซึ่งจะเป็นการ rondom matrix 2D ซึ่ง row  = resSize = 1000 and column = 1+inSize = 2 ซึ่ฟังชั่น .random.rand นั้น
 การกำหนดค่านั้นช่วงของค่าที่สุ่มจะอยู่ระหว่าง [0 ,1) ละนำมาลบกับ 0.5 จะกลายเป็น [-0.5 ,-0.5)  ซึ่งขอบเขตนั้นมันจะไม่ไปสุด -0.5 
 เพราะจะนั้นจึงเพิ่มการ * 1 เข้ามาทำให้ขอบเขตของการสุ่มกลายเป็น [-0.5, 0.5]  นี้คือเท่าที่ผมไปทำทำความเข้าใจมานะครับที่จริงผมอยากไปอธิบายเพิ่มเติมวันพุธนี้ด้วยนะครับ
ซึ่งจะเมื่อปริ้นWin ออกมาจะได้ 
[[-0.12545988  0.45071431]
 [ 0.23199394  0.09865848]
 [-0.34398136 -0.34400548]
 ...
 [ 0.25137509  0.15695516]
 [ 0.45661462 -0.43104198]
 [-0.44294528 -0.21781293]]
 เพราะฉะนั้น จะนำ Win ไป dot  กับ np.vstack((1,u)) ซึ่ง vstack คือต่อ row ของ matrix ซึ่งจะขึ้นต้นด้วย 1 
 และต่อถ้ายด้วย u=data[t] ซึ่ง t=0 จะได้ data[0] = 0.1220639965678425 นำมา vstack จะได้ [1
																		0.1220639965678425]
																		
เมื่อนำ Win dot np.vstack((1,u)) จะกลายเป็น array ขนาด 1000*1 และ นำไปบวกกับ np.dot( W, x )
โดย W= np.random.rand(resSize,resSize) - 0.5 ซึ่ง resSize = 1000 และ - 0.5 ก็คือขอบเขตเหมือนเดิม
จากนั้น  W *= 1.25 / rhoW หมายความว่า W = W*(125/rhoW) โดย rhoW = max(abs(linalg.eig(W)[0]))
abs คือ ฟังก์ชันคำนวณมิติของค่าลักษณะเฉพาะ
linalg.eig มาจาก numpy.linalg คือ โมดูลคำนวณค่าลักษณะเฉพาะของเมทริกซ์อินพุต W[0]
และคำนวนหาค่าที่มากที่้สุด max 
ซึ่งลองปริ้น W ก่อนหน้า จะออกมาได้
[[-0.23829432 -0.2530212   0.40625458 ... -0.19021214 -0.20995447
   0.37141403]
 [ 0.17270299  0.2966814  -0.2495321  ... -0.10542768  0.02994059
  -0.33863264]
 [ 0.07199588  0.30543233  0.26016093 ... -0.17215716  0.31574538
   0.09731238]
 ...
 [-0.38570885 -0.34019646  0.32572709 ... -0.08192802 -0.07132874
   0.42944855]
 [ 0.09515562 -0.13528286 -0.49462438 ...  0.36732638 -0.44192668
  -0.25046724]
 [-0.14107392  0.46060071 -0.21113738 ... -0.40885957  0.21537219
   0.03795453]]
   หลัง W = W*(125/rhoW)
   [[-0.03236014 -0.03436003  0.05516898 ... -0.02583062 -0.02851161
   0.05043766]
 [ 0.0234529   0.04028905 -0.03388622 ... -0.01431698  0.0040659
  -0.04598598]
 [ 0.00977697  0.04147741  0.0353296  ... -0.02337878  0.04287792
   0.01321493]
 ...
 [-0.05237889 -0.04619835  0.04423342 ... -0.01112575 -0.00968637
   0.05831869]
 [ 0.01292204 -0.01837128 -0.06716951 ...  0.04988256 -0.06001321
  -0.03401321]
 [ 0.0234529   0.04028905 -0.03388622 ... -0.01431698  0.0040659
  -0.04598598]
 [ 0.00977697  0.04147741  0.0353296  ... -0.02337878  0.04287792
   0.01321493]
 ...
 [-0.05237889 -0.04619835  0.04423342 ... -0.01112575 -0.00968637
   0.05831869]
  -0.04598598]
 [ 0.00977697  0.04147741  0.0353296  ... -0.02337878  0.04287792
   0.01321493]
 ...
 [-0.05237889 -0.04619835  0.04423342 ... -0.01112575 -0.00968637
   0.05831869]
 [ 0.01292204 -0.01837128 -0.06716951 ...  0.04988256 -0.06001321
  -0.03401321]
 [-0.0191577   0.06254913 -0.02867225 ... -0.05552273  0.02924733
   0.00515419]]
ซึ่ง x ก่อนหน้านี้ ที่ถูกกำหนดให้ x = np.zeros((resSize,1)) ซึ่งท้ายที่สุดนำ W dot กับ x ก้จะได้ 
[0.]
 [0.]
 [0.]
 .
 .
 .
 [0.]] อยู่ดีเนื่้องจากแค่เริ่มต้น
 
พอได้ผลลัพธุืของทั้งสอง  np.dot( Win, np.vstack((1,u)) ) กับ  np.dot( W, x ) แล้วก็นำมาบวกกัน แล้วนำไปเข้าฟังชั่น tanh และทำวนลูปไปเรื่อยๆ จะกว่าจะหมด ตัวที่ 1999 หรือเข้าไปเงื่อนไข
 if t >= initLen: 
        X[:,t-initLen] = np.vstack((1,u,x))[:,0]
		เป็นการเช็คเงื่อนไขว่า เมื่อ t >= 100 X[จะรับ row มาทั้งหมดจาก : , และ column t-100] = np.vstack((1,u,x))[เลือก row ทั้งหมด จาก :, และ column แรก 0]
 
 
 บรรทัด 58 
 Wout = linalg.solve( np.dot(X,X.T) + reg*np.eye(1+inSize+resSize), np.dot(X,Yt.T) ).T
  
 solve เป็น โมดุลของ linalg จาก Numpy library ซึ่งการหาค่า Wout จะอยู่ในรูปของ พีชคณิตเชิงเส้น  AX=B โดย A np.dot(X,X.T) + reg*np.eye(1+inSize+resSize)
 และ B = np.dot(X,Yt.T)
 ซึ่ง reg = 1e-8
 np.eye คือการสร้างเมตริกเอกลักษณ์
 